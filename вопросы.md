## Устные вопросы

1. Какой самый эффективный способ конкатенации строк? <br>
я бы подумал, что оптимальным должен быть `strings.Builder`, но [вот здесь](https://gist.github.com/dtjm/c6ebc86abe7515c988ec) есть бенчмарки, которые показывают, что простое складывание строк через знак `+` очень круто работает. А лучше всех bytes.Buffer с `buf.Reset()`.

2. Что такое интерфейсы, как они применяются в Go? <br>
интерфейсы в Go это именованный набор сигнатур методов. применяется для реализации полиморфизма.

3. Чем отличаются RWMutex от Mutex?
<br> RWMutex содержит RLock-RUnlock, который не блокирует конкурентных Reader'ов. Mutex блокирует всех.

4. Чем отличаются буферизированные и не буферизированные каналы? <br>
горутина без буфера зависает до момента ответа второй горутины с обратной стороны канала. Uber [рекомендует](https://github.com/uber-go/guide/blob/master/style.md#channel-size-is-one-or-none) не использовать буферные каналы, поскольку зависшая на канале горутина даёт сигнал sysmon'y рантайма дать повышенный приоритет второй горутине этого канала.

5. Какой размер у структуры `struct{}{}`? <br> 
0 байт. этот лайфхак в го используют как пустую заглушку в каналах и хэш-мапах.

6. Есть ли в Go перегрузка методов или операторов? <br>
перегрузки операторов в Go нет. перегрузка методов до версии 1.18 была возможна через интерфейсные аргументы функции. но теперь для этого есть дженерики.

7. В какой последовательности будут выведены элементы `map[int]int{0:1,1:124,2:281}`? <br> 
если речь про последовательность элементов хэш-мап в цикле `for-range`, то рандомно.

8. В чем разница make и new?
<br> make() задумана для выделения памяти под сложные типы (слайсы, мапы и каналы), new() такого не сумеет.

9. Сколько существует способов задать переменную типа slice или map? <br>
всего способа четыре, но Uber [утверждает](https://github.com/uber-go/guide/blob/master/style.md#initializing-maps), что юзабельны только два: make() и литерал.

10. Что выведет [данная программа](https://go.dev/play/p/rYF0URs9i5E) и почему? <br>
этот код выведет `1 1`, что  связано с темами variable shadowing и copy by value, в функцию update попадает лишь копия указателя p, которая исчезнет при завершении update(). чтобы код в update() повлиял на main(), вместо `p = &b` нужно `*p = b`.

11. Что выведет [данная программа](https://go.dev/play/p/dIImieVIJEz) и почему? <br>
мне эта программа вывела кучу ошибок, всё из-за того же copy by value. варианты решения: передать [wg указателем](https://go.dev/play/p/0lIzCrepwhK) либо просто [через closure](https://go.dev/play/p/g84tWdNmiyz).

12. Что выведет [данная программа](https://go.dev/play/p/XQRymf_HoPW) и почему? <br>
снова проблема variable shadowing. Программа выводит `0`, поскольку `if` создаеёт отдельную область видимости.

13. Что выведет [данная программа](https://go.dev/play/p/CZsB9oVmVEa) и почему? <br>
это задание схоже с заданием №10. программа выводит `[100 2 3 4 5]`, поскольку Слайс в Go это ссылочный тип, поэтому изменение элементов слайса внутри someAction() изменяет изначальный слайс в main() как если бы мы передали в функцию someAction() переменную по указателю. Но append() внутри someAction()под капотом создаёт новый слайс, ссылка на который кладётся в переменную с тем же именем v (снова variable shadowing), и отправляется к garbage-collector'у по завершению someAction().

14. Что выведет [данная программа](https://go.dev/play/p/9USpjZRB-sT) и почему? <br>
программа выведет `[b b a][a a]` по причинам указанным в ответе на предыдущее задание №13.
